---
title: "Meta Time Series Analysis"
author: "Ryan_Gan"
date: "May 8, 2017"
output: html_document
---

## Background

This is a pooled analysis of state and year specific time-series evaluating the association between wildfire smoke exposure and cardipulmonary outcomes in the Western United States. 

### Notable differences between Washington and Oregon:

*Health Data:* Washington CHARS data captures persons who visited a hosptial in the state. Oregon data is insurance based and captures insured persons billed for a medical visit in the state of Oregon. 

*Smoke Data:* Washington smoke estimates were in general more accurate when compared with surface monitor estimates comapred to Oregon.

Both state datasets were limited to only emergency room visits (billed for Oregon, observed for Washington).

```{r libaries, message = F, warning = F}
library(tidyverse)
library(lme4)
library(broom)
library(maps)
# loading gganimate (David Robinson's package on Github)
# still experimental and likely has some bugs
#library(gganimate)
#library(animation)

# two-stage distributed lag model libraries
library(dlnm)
library(mvmeta)
```

Read in meta time series data.

```{r read data, message = F, warning = F}
meta_ts <- read_csv("./data/meta_timeseries.csv") %>% 
  # creating 10 unit increase var of geo smoke and day of week
  mutate(geo_smk10 = geo_smk_pm/10,
         day = weekdays(date),
         state_county = paste(state, county, sep = "_")) %>% 
  # creating lag variables for a crude distributed lag
  group_by(state_county) %>% 
  # create smoke and lag variables
  mutate(smoke0 = ifelse(geo_smk_pm > 0, 1, 0),
         smoke5 = ifelse(geo_smk_pm > 5, 1, 0),
         smoke10 = ifelse(geo_smk_pm > 10, 1, 0),
         smoke15 = ifelse(geo_smk_pm > 15, 1, 0), 
         # lag variable
         geo_smk_lag1 = lag(geo_smk10, 1, order_by = state_county),
         geo_smk_lag2 = lag(geo_smk10, 2, order_by = state_county),
         geo_smk_lag3 = lag(geo_smk10, 3, order_by = state_county),
         geo_smk_lag4 = lag(geo_smk10, 4, order_by = state_county),
         geo_smk_lag5 = lag(geo_smk10, 5, order_by = state_county),
         geo_smk_lag6 = lag(geo_smk10, 6, order_by = state_county),
         geo_smk_lag7 = lag(geo_smk10, 7, order_by = state_county)) %>% 
  ungroup()

# smoke wave days (at least 2 consecutive days in the 98th percentile of PM)
quantile(meta_ts$geo_wt_pm, probs = c(0.95,0.98,0.99, 0.999))
# following Coco's smoke wave day, the 98th percentile for PM2.5 concentrations
# would be >26.9

smoke_wave <- meta_ts %>% 
  select(state, county, date, geo_wt_pm) %>% 
  mutate(high_pm_day = ifelse(geo_wt_pm > 26.9, 1, 0)) %>% 
  group_by(state, county) %>% 
  # identify consecutive days
  mutate(smoke_wave = ifelse(lag(high_pm_day, 
    order_by = county)==1 & high_pm_day ==1, 1, 0)) %>% 
  select(-high_pm_day, -geo_wt_pm)

# merge in smokewave day
meta_ts <- meta_ts %>% 
  right_join(smoke_wave, by = c("state", "county", "date"))

# washington
wa_ts <- meta_ts %>% filter(state == "WA")
# oregon
or_ts <- meta_ts %>% filter(state == "OR")

# count of state outcome timeseries
state_outcome_rate <- meta_ts %>% group_by(state, date) %>% 
  # remove columns I don't want to calculate
  select(-fips, -county) %>% 
  # add up outcomes in each county
  summarise_each(funs(sum), population, n_obs:broken_arm_n) %>% 
  mutate_each(funs((./population*100000)), n_obs:broken_arm_n) 

# average of environmental measures, joined with outcomes
state_smoke <- meta_ts %>% group_by(state, date) %>% 
  select(-fips, -county) %>% 
  summarise_each(funs(mean, median, min, max), wrf_pm:wrf_temp) %>% 
  full_join(state_outcome_rate, by = c("state", "date"))

```

I also incorporated the smoke-wave day approach by Coco Liu where I identified the 98th percentile of the observed PM2.5 values for the GWR estimates (without background PM2.5 subtracted off). Then I set the binary cutoff of at least two days of levels above this 98th percentile as a smoke wave day.

Comparing smoke-wave approach to our method of defining smoke days

```{r smoke days, message=F, warning=F}
# only 150 smoke wave days
xtabs(~smoke_wave,  meta_ts)
# if we compare to our geo smoke > 10, we'd add 362 extra days
xtabs(~smoke_wave + smoke10, meta_ts)
# if we used smoke >15 we'd add 164 extra days 
xtabs(~smoke_wave + smoke15, meta_ts)
```

## Descriptive Plots

First step is to determine if there are any notable differences between the states. Going to aggregate counties by state (averaging health outcomes and smoke) and split states to Washington and Oregon.

### Visualizing Exposure Time Series

Small multiples of smoke exposure series by smoke estimation method for each county within each state.

#### Washington 2012 Smoke Time Series

```{r washington smoke, message = F, warning = F, results = "asis"}

# small multiples dataset
wa_smk <- wa_ts %>% 
  select(county, date, wrf_smk_pm, krig_smk_pm, geo_smk_pm) %>% 
  gather(key = smk_method, value = pm, -date, - county)
  
  
wa_smk_plot <- ggplot(wa_smk, aes(x = date, y = pm)) +
  geom_point(aes(colour = smk_method), alpha = 0.8, size = 0.8) +
  ggtitle("Washington: 2012 Fire Season Smoke PM2.5") +
  facet_wrap(~county) +
  ylab("Smoke PM2.5 ug/m^3") +
  xlab("Year: 2012") +
  theme_bw()

wa_smk_plot

```

#### Oregon 2013 Smoke Time Series

```{r oregon smoke, message = F, warning = F, results = "asis"}

# small multiples dataset
or_smk <- or_ts %>% 
  select(county, date, wrf_smk_pm, krig_smk_pm, geo_smk_pm) %>% 
  gather(key = smk_method, value = pm, -date, -county)
  
  
or_smk_plot <- ggplot(or_smk, aes(x = date, y = pm)) +
  geom_point(aes(colour = smk_method), alpha = 0.8, size = 0.8) +
  facet_wrap(~county) +
  ggtitle("Oregon: 2013 Fire Season Smoke PM2.5") +
  ylab("Smoke PM2.5 ug/m^3") +
  xlab("Year: 2013") +
  theme_bw()

or_smk_plot

```

Seems like the southwest portion of Oregon was affected by smoke where the rest of the state did not have much smoke exposure. The smoke exposure timeframe also appears to have a smaller window of time on which it affected the area.

#### Maps of Number of Days Counties Affected by Smoke

*Washington*

```{r static wash smoke map, message=F, warning=F, results="asis"}

# data wrangle ----
#first step is to summarise the counts of smoke days in each county 
wa_smk_count <- meta_ts %>% filter(state=="WA") %>% 
  group_by(county) %>% 
  # summing up smoke days
  summarise(smk_wave_n = sum(smoke_wave), smk_day0 = sum(smoke0), 
            smk_day5 = sum(smoke5), smk_day10 = sum(smoke10),
            smk_day15 = sum(smoke15)) %>% 
  # county needs to be lowercase to join to maps dataframe
  mutate(county = tolower(county))

# maps package will be loaded to pull map data and create a dataframe
wa_county_df <- map_data("county", "washington")

# join county counts to map df
wa_smk_df <- wa_county_df %>% 
  right_join(wa_smk_count, by = c("subregion" = "county")) %>% 
  # small multiples of different smoke cutoff methods
  gather(key = smk_cut_method, value = smoke_days, -long:-subregion) %>% 
  # filter out smoke day 0 since it's not very specific
  filter(smk_cut_method != "smk_day0") %>% 
  # rename smoke day cutoffs 
  mutate(smk_cut_method = 
    ifelse(smk_cut_method == "smk_day5","Smoke PM2.5 > 5 ug/m^3",
    ifelse(smk_cut_method == "smk_day10", "Smoke PM2.5 > 10 ug/m^3",
    ifelse(smk_cut_method == "smk_day15", "Smoke PM2.5 > 15 ug/m^3",
    ifelse(smk_cut_method == "smk_wave_n", "Smoke Wave", NA)))),
    # preserve smoke method order for small multiple
    smk_cut_method = factor(smk_cut_method, 
      levels = c("Smoke PM2.5 > 5 ug/m^3", "Smoke PM2.5 > 10 ug/m^3", 
                 "Smoke PM2.5 > 15 ug/m^3", "Smoke Wave")))

# map ----

# smoke days where GWR smoke > 15
smoke_map <- ggplot(wa_smk_df, aes(x=long, y=lat, group=group)) +
  # fill with number of smoke days
  geom_polygon(aes(fill = smoke_days), alpha = 0.7) +
  scale_fill_gradient("Smoke-Impacted Days",
                      low = "#0b486b", high = "#f56217") +
  # add county path on top
  geom_path() +
  facet_wrap(~smk_cut_method) +
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Washington: Counties affected by smoke") +
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.background = element_rect(colour=NA, fill=NA))

smoke_map

```

Attempting an animated plot. Doesn't seem to work on my PC for some reasons which I think has to do with the ImageMagick software. I'll figure it out later. 

```{r animated wash smoke map, message=F, warning=F, results="asis", eval = F}

# data wrangle ----
wa_smk_days <- wa_ts %>% 
  select(county, date, smoke5, smoke10, smoke15, smoke_wave) %>% 
  # county needs to be lowercase to join to maps dataframe
  mutate(county = tolower(county)) %>% 
  # need to gather smoke variables by date
  gather(key = smk_cut_method, value = smoke_days, -date, -county) %>% 
  # maybe too many dates, going to filter to just september to october
  filter(date >= "2012-09-15" & date <= "2012-10-01")
  
summary(wa_smk_days)
# join county counts to map df
wa_smk_df <- wa_county_df %>% 
  right_join(wa_smk_days, by = c("subregion" = "county")) %>% 
  filter(smk_cut_method != "smk_day0") %>% 
  # rename smoke day cutoffs 
  mutate(smk_cut_method = 
    ifelse(smk_cut_method == "smoke5","Smoke PM2.5 > 5 ug/m^3",
    ifelse(smk_cut_method == "smoke10", "Smoke PM2.5 > 10 ug/m^3",
    ifelse(smk_cut_method == "smoke15", "Smoke PM2.5 > 15 ug/m^3",
    ifelse(smk_cut_method == "smoke_wave", "Smoke Wave", NA)))),
    # preserve smoke method order for small multiple
    smk_cut_method = factor(smk_cut_method, 
      levels = c("Smoke PM2.5 > 5 ug/m^3", "Smoke PM2.5 > 10 ug/m^3", 
                 "Smoke PM2.5 > 15 ug/m^3", "Smoke Wave")))

# map ----

# smoke days where GWR smoke > 15
smoke_map <- ggplot(wa_smk_df, aes(x=long, y=lat, group=group, frame = date)) +
  # fill with number of smoke days
  geom_polygon(aes(fill = smoke_days), alpha = 0.7) +
  scale_fill_gradient("Smoke-Impacted Days",
                      low = "#0b486b", high = "#f56217") +
  # add county path on top
  geom_path() +
  facet_wrap(~smk_cut_method) +
  xlab("Longitude") +
  ylab("Latitude") +
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.background = element_rect(colour=NA, fill=NA))

gganimate(smoke_map, "output.gif")

ggani
ani.options()

magickPath <-shortPathName("C:\\Program Files\\ImageMagick-7.0.5-Q16\\magick.exe")
ani.options(convert=magickPath)
```

*Oregon*

```{r static oregon smoke map, message=F, warning=F, results="asis"}

# data wrangle ----
#first step is to summarise the counts of smoke days in each county 
or_smk_count <- meta_ts %>% filter(state=="OR") %>% 
  group_by(county) %>% 
  # summing up smoke days
  summarise(smk_wave_n = sum(smoke_wave), smk_day0 = sum(smoke0), 
            smk_day5 = sum(smoke5), smk_day10 = sum(smoke10),
            smk_day15 = sum(smoke15)) %>% 
  # county needs to be lowercase to join to maps dataframe
  mutate(county = tolower(county))

# maps package will be loaded to pull map data and create a dataframe
or_county_df <- map_data("county", "oregon")

# join county counts to map df
or_smk_df <- or_county_df %>% 
  right_join(or_smk_count, by = c("subregion" = "county")) %>% 
  # small multiples of different smoke cutoff methods
  gather(key = smk_cut_method, value = smoke_days, -long:-subregion) %>% 
  # filter out smoke day 0 since it's not very specific
  filter(smk_cut_method != "smk_day0") %>% 
  # rename smoke day cutoffs 
  mutate(smk_cut_method = 
    ifelse(smk_cut_method == "smk_day5","Smoke PM2.5 > 5 ug/m^3",
    ifelse(smk_cut_method == "smk_day10", "Smoke PM2.5 > 10 ug/m^3",
    ifelse(smk_cut_method == "smk_day15", "Smoke PM2.5 > 15 ug/m^3",
    ifelse(smk_cut_method == "smk_wave_n", "Smoke Wave", NA)))),
    # preserve smoke method order for small multiple
    smk_cut_method = factor(smk_cut_method, 
      levels = c("Smoke PM2.5 > 5 ug/m^3", "Smoke PM2.5 > 10 ug/m^3", 
                 "Smoke PM2.5 > 15 ug/m^3", "Smoke Wave")))

# map ----

# smoke days where GWR smoke > 15
smoke_map <- ggplot(or_smk_df, aes(x=long, y=lat, group=group)) +
  # fill with number of smoke days
  geom_polygon(aes(fill = smoke_days), alpha = 0.7) +
  scale_fill_gradient("Smoke-Impacted Days",
                      low = "#0b486b", high = "#f56217") +
  # add county path on top
  geom_path() +
  facet_wrap(~smk_cut_method) +
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Oregon: Counties affected by smoke") +
  theme(panel.background = element_rect(fill = 'white', colour = 'black'),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    strip.background = element_rect(colour=NA, fill=NA))

smoke_map

```


### Visualizing Health Outcome Time Series

Comparison between Oregon and Washington aggregated health outcomes over time.

```{r state outcome trends, message = F, warning = F, results = "asis"}
# I want CVD and respiratory rates by each state so I can make a 4 panel
state_cvd_resp <- state_outcome_rate %>% 
  select(state, date, cvd_n, resp_n) %>% 
  gather(key = outcome, value = n, -date, -state)
  

count_plot <- ggplot(state_cvd_resp, aes(x = date, y = n)) +
  geom_point() +
  facet_wrap(~state+outcome, scales = "free") +
  ylab("Outcome Rate Per 100k Person") +
  xlab("Date") +
  theme_bw()


count_plot
```

CVD rates in Oregon for 2013 and Washington 2012 were similar, with no clear trend in the outcome rate over time. 

All respiratory outcomes were slightly different between Washington and Oregon. It looks like Oregon has almost twice the respiratory ER rate compared to Washington. This could mean some difference in respiratory rates between states, or more likely could have something to do with the different data sources. I'll need to think about this more. Justifies accounting for state though. Also, both states appear to have trends in respiratory ER visits where there is a decline in summer months, with an increase in the rate around the fall. Oregon has a pretty pronounced seasonal variation. 

It would be good to take a look at state-specific outcome time-series.

### Washington Health Outcomes Time Series

```{r wash health, warning=F, message=F, results='asis'}

# small multiples dataset
wa_health <- wa_ts %>% 
  select(county, date, population, n_obs:broken_arm_n) %>% 
  gather(key = outcome, value = events, -date, -county, -population) %>% 
  mutate(rate_per_100k = (events/population)*100000) %>% 
  filter(outcome == "resp_n" | outcome == "cvd_n")

#glimpse(wa_health)

# plot of rates
count_plot <- ggplot(wa_health, aes(x=date, y=events)) +
  geom_point(aes(colour = outcome), alpha = 0.8, size = 0.8) +
  facet_wrap(~county, scales = "free") +
  ggtitle("Washington: 2012 Fire Season Respiratory and CVD Rates") +
  ylab("Rates Per 100k") +
  xlab("Year:2012") +
  theme_bw()

count_plot
```


*Oregon*

```{r oregon health, message=F, warning=F, results='asis'}
# small multiples dataset
or_health <- or_ts %>% 
  select(county, date, population, n_obs:broken_arm_n) %>% 
  gather(key = outcome, value = events, -date, -county, -population) %>% 
  mutate(rate_per_100k = (events/population)*100000) %>% 
  filter(outcome == "resp_n" | outcome == "cvd_n")

# plot of rates
count_plot <- ggplot(or_health, aes(x=date, y=events)) +
  geom_point(aes(colour = outcome), alpha = 0.8, size = 0.8) +
  facet_wrap(~county, scales = "free") +
  ggtitle("Oregon: 2013 Fire Season Respiratory and CVD Rates") +
  ylab("Rates Per 100k") +
  xlab("Year:2013") +
  theme_bw()

count_plot

```



### Scatter Plot of Outcome Rates and Geo Smoke PM~2.5~

Visualizing rates of outcomes by 10ug/m^3 increasing Geoweighted smoke PM~2.5~.

```{r scatter plot, message=F, warning=F, results="asis"}
# calclating rates per 100k
rate_df <- meta_ts %>% mutate_at(
    which(colnames(meta_ts)=="n_obs"):which(colnames(meta_ts)=="broken_arm_n"),
    funs((./population)*100000)) %>% 
  mutate_at(c("wrf_smk_pm", "krig_smk_pm", "geo_smk_pm"),
    funs(./10)) %>% 
  select(state, county, date, geo_smk_pm, geo_wt_pm,
  which(colnames(meta_ts)=="n_obs"):
  which(colnames(meta_ts)=="broken_arm_n")) %>% 
  gather(key = outcome, value = rate_100k, -state, 
         -county, -date, -geo_smk_pm, -geo_wt_pm) %>% 
  filter(outcome != "n_obs")
  

# plot of pm2.5 every 10 units and asthma
ggplot(rate_df, aes(x = geo_smk_pm, y = log(rate_100k+0.1))) +
  geom_point(aes(colour = state), alpha = 0.2,  size = 1) + 
  scale_colour_manual(values = c("red", "blue")) +
  # truncated y axis
  #scale_y_continuous(limits = c(0, 1.5)) +
  # fit line for Washington
  geom_smooth(data = filter(rate_df, state == "WA"), 
              method=lm, formula = y~x, se = F, colour = "blue") +
  # fit line for Oregon
  geom_smooth(data = filter(rate_df, state == "OR"),
              method=lm, formula = y~x, se = F, colour = "red") +
  facet_wrap(~outcome, scale  = "free") +
  ylab("Log Outcome Rate per 100,000 Persons") +
  xlab("GWR Smoke PM2.5 per 10ug/m^3") +
  theme_bw()  

```

It looks like there is a linear relationship with smoke and asthma (expected), maybe with cerebrovascular disease, COPD, and respiratory outcomes.

### Standard Regression Models

Same-day estimates of association between smoke via GWR and outcomes.

```{r standard analysis, message=F, warning=F, results="asis"}
# create empty dataframe
rr_df <- data.frame(matrix(nrow = 12, ncol = 4))
colnames(rr_df) <- c("outcome", "rel_risk", "lower_95", "upper_95")

# vector of outcomes
outcome_list <- colnames(meta_ts[, which(colnames(meta_ts)=="resp_n"):
    which(colnames(meta_ts)=="broken_arm_n")])

# names 
outcome_names <- c('All Respiratory', 'Asthma', 'COPD', 'Pneumonia', 
  'Acute Bronchitis', 'Cardiovascular Disease', 'Arrhythmia', 
  'Cerebrovascular Disease', 'Heart Failure', 'Ischemic Heart Disease',
  'Myocardial Infarction', 'Broken Arm')

# populate outcome column
rr_df[,1] <- factor(outcome_names, levels=unique(outcome_names))

meow <- lapply(outcome_list, function(x){

 smk_est <- tidy(glm(as.formula(paste0(x, 
    "~ geo_smk10 + wrf_temp + state + county + 
    day + offset(log(population))")), 
    meta_ts, family="quasipoisson"))[2, ]
 
 rr <- c(round(exp(smk_est[1,2]),3),
         round(exp(smk_est[1,2]-1.96*smk_est[1,3]),3),
         round(exp(smk_est[1,2]+1.96*smk_est[1,3]),3))
 
}) # end apply

for(i in 1:nrow(rr_df)){
  rr_df[i,2:4] <- meow[[i]]
}

# add in a grouping variable
rr_df$group <- NA
rr_df[1:5, 5] <- "Respiratory"
rr_df[6:11, 5] <- "CVD"
rr_df[12, 5] <- "Broken Arm"

# tried apply function and it might have been easier to just use a loop
# as I needed a for loop to fill the list in to the dataframe
# code is more compact though
# I should check speed (or make a custom function to do this one day)

ggplot(rr_df, aes(x=outcome, y = rel_risk, colour = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.2) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  theme(
   panel.background = element_rect(fill = 'white', colour = 'black'),
   panel.grid.major = element_blank(),
   panel.grid.minor = element_blank(),
   axis.text.x = element_text(angle = 90, vjust = .75)) +
  ylab("Relative Risk") +
  xlab("Outcome") +
  ggtitle("Relative Risk for a 10ug/m^3 increase PM2.5 estimated via GWR Smoke")
```

Smoke-wave associations with outcomes.

```{r standard analysis smoke wave, message=F, warning=F, results="asis"}
# create empty dataframe
rr_df <- data.frame(matrix(nrow = 12, ncol = 4))
colnames(rr_df) <- c("outcome", "rel_risk", "lower_95", "upper_95")

# vector of outcomes
outcome_list <- colnames(meta_ts[, which(colnames(meta_ts)=="resp_n"):
    which(colnames(meta_ts)=="broken_arm_n")])

# names 
outcome_names <- c('All Respiratory', 'Asthma', 'COPD', 'Pneumonia', 
  'Acute Bronchitis', 'Cardiovascular Disease', 'Arrhythmia', 
  'Cerebrovascular Disease', 'Heart Failure', 'Ischemic Heart Disease',
  'Myocardial Infarction', 'Broken Arm')

# populate outcome column
rr_df[,1] <- factor(outcome_names, levels=unique(outcome_names))

meow <- lapply(outcome_list, function(x){

 smk_est <- tidy(glm(as.formula(paste0(x, 
    "~ smoke_wave + wrf_temp + state + county + 
    day + offset(log(population))")), 
    meta_ts, family="quasipoisson"))[2, ]
 
 rr <- c(round(exp(smk_est[1,2]),3),
         round(exp(smk_est[1,2]-1.96*smk_est[1,3]),3),
         round(exp(smk_est[1,2]+1.96*smk_est[1,3]),3))
 
}) # end apply

for(i in 1:nrow(rr_df)){
  rr_df[i,2:4] <- meow[[i]]
}

# add in a grouping variable
rr_df$group <- NA
rr_df[1:5, 5] <- "Respiratory"
rr_df[6:11, 5] <- "CVD"
rr_df[12, 5] <- "Broken Arm"

# tried apply function and it might have been easier to just use a loop
# as I needed a for loop to fill the list in to the dataframe
# code is more compact though
# I should check speed (or make a custom function to do this one day)

ggplot(rr_df, aes(x=outcome, y = rel_risk, colour = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.2) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  theme(
   panel.background = element_rect(fill = 'white', colour = 'black'),
   panel.grid.major = element_blank(),
   panel.grid.minor = element_blank(),
   axis.text.x = element_text(angle = 90, vjust = .75)) +
  ylab("Relative Risk") +
  xlab("Outcome") +
  ggtitle("Relative risk for exposure to a smoke-wave")
```

### Crude Mediation

```{r mediation, eval = F}
smk_pm <- lmer(geo_wt_pm ~ smoke_wave + wrf_temp + (1|day) +
                     (1|county) + (1|state), meta_ts)
# smoke is associated with higher pm2.5
summary(smk_pm)

# smoke is associated with asthma
smk_asthma <- glmer(asthma_n ~ smoke_wave + wrf_temp + (1|day) +
                     (1|county) + (1|state) +
                     offset(log(population)), 
                     meta_ts, family="poisson")
summary(smk_asthma)

# add in geo wt pm
mediation <- glmer(asthma_n ~ smoke_wave + geo_wt_pm + 
                     wrf_temp + (1|day) +
                     (1|county) + (1|state) +
                     offset(log(population)), 
                     meta_ts, family="poisson")

summary(mediation)


```


### Interaction Model

```{r interaction, message=F, warning=F, results="asis", eval = F}
smoke_pm_int <- glmer(asthma_n ~ smoke15 + geo_wt_pm + smoke10:geo_wt_pm + 
                     wrf_temp + (1|day) +
                     (1|county) + (1|state) +
                     offset(log(population)), 
                     meta_ts, family="poisson")

summary(smoke_pm_int)

```

### Mixed Model

```{r mixed mod analysis, message=F, warning=F, results="asis", eval = F}
mixed_mod <- glmer(asthma_n ~ smoke_wave + wrf_temp + (1|day) +
                     (1|county) + (1|state) +
                     offset(log(population)), 
                     meta_ts, family="poisson")

summary(mixed_mod)

```


### Distributed Lag With Covariates in Model

Set up list of counties to run through two-stage distributed lag.

```{r two stage dl setup, message=F, warning=F}

# create vector of state_county
counties <- as.character(unique(meta_ts$state_county))

# create dataframe list of each county
county_list_df <- lapply(counties, function(x) 
  meta_ts[meta_ts$state_county==x,])
# assign each element of the list object the county name
names(county_list_df) <- counties
# calculate length of counties (75)
m <- length(counties)

# GWR PM2.5 ranges
smk_range <- t(sapply(county_list_df, 
  function(x) range(x$geo_smk10,na.rm=T)))
# smk_range

# population range
pop_range <- t(sapply(county_list_df, 
  function(x) range(x$population,na.rm=T)))
# pop_range
# -----

# function to compute the QAIC (quasi-poisson AIC)
fqaic <- function(model) {
  loglik <- sum(dpois(model$y,model$fitted.values,log=TRUE))
  phi <- summary(model)$dispersion
  qaic <- -2*loglik + 2*summary(model)$df[3]*phi
  return(qaic)
}

```



```{r qaic model fit loop 2-stage dl, message=F, warning=F}

# assuming linear relationship between smoke and outcomes
argvar <- list(fun="lin")
# I'm not certain on time lag yet, but maybe a week makes sense
lag <- 7

# create outcome list to loop through
outcome_names <- colnames(meta_ts[,which(colnames(meta_ts)=="resp_n"):
  which(colnames(meta_ts)=="broken_arm_n")])
# copd is having issues; i suspect counties with no events is the problem
# empty vector to fill with error messages of counties where models can be run
# mostly due to no variation in the outcome (i.e. all 0s in the time series)

fit_matrix <- matrix(NA, nrow=0, ncol=6)
colnames(fit_matrix) <- c("outcome", "exposure", "fit_type", "df", "aic",
                           "n_mod_conv")

system.time(
# 1st loop: loop through outcomes
for(q in seq(outcome_names)){

# 2nd loop: vary degrees of freedom for lag knots
# set up empty matrix to assess model fit
fit_mat <- matrix(NA, nrow = 3, ncol = 6) 

  # 2 df will not work for a spline, going from 3 to 6 df
  for(h in 3:5){ # start loop for df

    # fitting a natural spline for lag with 5 knots?
    fit_mat[h-2, 4] <- degree_freedom <- h
    arglag <- list(fun="ns", df=degree_freedom)
  
    # overall cumulative summaries
    # columns need to match degrees of freedom for lag
    # q: do i need to make this object multiple times or just fill it in?
    cumulative_counties <- matrix(NA, length(county_list_df), 
      as.numeric(degree_freedom), 
      dimnames=list(counties,paste("b",seq(degree_freedom),sep="")))
    
    names(cumulative_counties) <- counties
    
    # (co)variance matrices
    counties_cov <- vector("list",length(county_list_df))
    names(counties_cov) <- counties
    
    # I also want to make a matrix of county-level models that fail to converge
    converge <- matrix(NA, length(county_list_df), 1,
      dimnames=list(counties, "converge"))
    
    # empty table to log degrees of freedom and AIC for each outcome
    
    # qaic
    qaic_val <- 0

    # first stage ----
    # loop for each county
    for(i in seq(county_list_df)) {
      # if error in following code, move on to next county
      tryCatch({
      # load county-specific dataframe
      sub <- county_list_df[[i]]
      
      # run only if there is at least one observation of outcome in ts
      #if(max(sub[, which(colnames(sub)==outcome_names[[q]])]) > 2){

      # define the cross-basis ----
      suppressWarnings({
      # cross-basis for smoke
      smk_cb <- crossbasis(sub$geo_smk10,lag=lag,argvar=argvar,arglag=arglag)
      # cross-basis for temp
      temp_cb <- crossbasis(sub$wrf_temp, lag = lag, argvar = argvar,
                            arglag = arglag)
      })
  
      # run the first stage county-specific models
      county_model <- glm(as.formula(paste0(outcome_names[q], 
        "~ smk_cb + temp_cb + offset(log(population))")), 
        family = "quasipoisson", sub)
      
      # alert warning if there are convergence issues
      converge[i,] <- county_model$converged
      
      # reduction to summary results ---
      # prediction summary for smoke 10 ug/m^3 
      # uses cross reduce function
      suppressWarnings({
        cr_counties <- crossreduce(smk_cb, county_model, type = "var", value = 1)

        })
     # }# end if statement

      # store results in matrix ---
      # daily lag results
      cumulative_counties[i,] <- coef(cr_counties)
      counties_cov[[i]] <- vcov(cr_counties)
      
      # Q-AIC
      qaic_val[i] <- fqaic(county_model)
      
        }, error = function(e){
          print(names(county_list_df[i]))
          }
        ) # end try catch

      } # end loop for county estimates

    # error at hood river; using trycatch to keep going
    #which(counties[]=="OR_Hood River")
    
    # fill in the fit matrix ----
    fit_mat[,1] <- outcome_names[q]
    fit_mat[,2] <- exposure <- "wrf_smk10"
    fit_mat[,3] <- "ns"
    # subset qaic to only models that converged
    # sum the grand q aic and fill fit matrix
    fit_mat[h-2,5] <- round(sum(qaic_val[!is.na(converge)[]==T]),2)
    # fill in number of county models that successfully converge
    fit_mat[h-2, 6] <- length(which(converge==T))
    sum(complete.cases(qaic_val))

    } # end model fit loop
  
  fit_matrix <- rbind(fit_matrix, fit_mat)

}) # end outcome loop and system time

# now that we have a range of df/knots, I want to filter to the minimum aic
# for each outcome and print out that value in a table

lag_spline_best_fit <- as_tibble(fit_matrix) %>%  
  group_by(outcome) %>% 
  slice(which.min(aic))

# kable
knitr::kable(lag_spline_best_fit, caption = paste0("Distributed lag spline",
  "degree of freedom best fit by AIC"))
```

Now that the degrees of freedom of the lag spline has been decided by lowest AIC, I'll run the loop for actual results.

```{r distributed lag results, message=F, warning=F, results="asis"}

# set estimation method for multivariate approach
# reml estimation method
method <- "reml"

# going row by row of the fit tibble

# produce results using fit matrix
system.time()
# 1st loop: loop through outcomes
for(j in 1:length(lag_spline_best_fit$outcome)){
  
  j <- 3
    # easiest to set out the parameters from the start
    outcome <- lag_spline_best_fit$outcome[j]
    degree_freedom <- as.numeric(lag_spline_best_fit$df[j])
  
    arglag <- list(fun="ns", df=degree_freedom)
  
    # overall cumulative summaries
    # columns need to match degrees of freedom for lag
    # q: do i need to make this object multiple times or just fill it in?
    cumulative_counties <- matrix(NA, length(county_list_df), 
      as.numeric(degree_freedom), 
      dimnames=list(counties,paste("b",seq(degree_freedom),sep="")))
    
    names(cumulative_counties) <- counties
    
    # (co)variance matrices
    counties_cov <- vector("list",length(county_list_df))
    names(counties_cov) <- counties
    
    # I also want to make a matrix of county-level models that fail to converge
    converge <- matrix(NA, length(county_list_df), 1,
      dimnames=list(counties, "converge"))

    # first stage loop for each county ----
    for(i in seq(county_list_df)) {
      # if error in following code, move on to next county using trycatch
      tryCatch({
      # load county-specific dataframe
      sub <- county_list_df[[i]]
      
      # define the cross-basis
      suppressWarnings({
      # cross-basis for smoke
      smk_cb <- crossbasis(sub$geo_smk10,lag=lag,argvar=argvar,arglag=arglag)
      # cross-basis for temp
      temp_cb <- crossbasis(sub$wrf_temp, lag = lag, argvar = argvar,
                            arglag = arglag)
      })
  
      # run the first stage county-specific models
      county_model <- glm(as.formula(paste0(outcome, 
        "~ smk_cb + temp_cb + offset(log(population))")), 
        family = "quasipoisson", sub)
      
      # alert warning if there are convergence issues
      converge[i,] <- county_model$converged
      
      # reduction to summary results ---
      # prediction summary for smoke 10 ug/m^3 
      # uses cross reduce function
      suppressWarnings({
        cr_counties <- crossreduce(smk_cb, county_model, type = "var", value = 1)
        })
     # }# end if statement

      # store results in matrix ---
      # daily lag results
      cumulative_counties[i,] <- coef(cr_counties)
      counties_cov[[i]] <- vcov(cr_counties)
        }, error = function(e){
          print(names(county_list_df[i]))
          }) # end try catch

      } # end loop for county estimates

  # second stage multivariate meta analysis ----
  # first step is to reduce the county-specific matrix to those that converged
  meta_counties <- cumulative_counties[converge[]==T, ]
  # reduce covariance matrix to models that converged
  meta_cov <- counties_cov[converge[]==T]
  
  # overall pooled summary for asthma model
  cumulative_mv_meta <- mvmeta(meta_counties~1, meta_cov, method = method)
  
  # meta summary of crossbasis
  # ask ander how these estimates work
  summary(cumulative_mv_meta)
  
  # create bases for prediction ----
  # bases of smoke lag (7 days with 10 intervals in each)
  xlag <- 0:70/10
  blag <- do.call("onebasis",c(list(x=xlag),attr(smk_cb,"arglag")))

  # county-specific first stage summaries
  county_lag_estimates <- apply(cumulative_counties,1, function(x) exp(blag%*%x))
  
  # prediction for a grid of lag days
  # predictor-specific summaries for 10 ug/m^3 of smoke
  pooled_cp <- crosspred(blag, coef=coef(cumulative_mv_meta), 
    vcov=vcov(cumulative_mv_meta), model.link="log", at = xlag)


# fill lag relationship with outcome tibble
# empty matrix to fill in distributed lag values
outcome_smk_lag_df <- as_tibble(matrix(NA,  
  nrow = 0, ncol = 5))
# assign outcome name
colnames(outcome_smk_lag_df) <- c("outcome", "lag", "rel_risk", 
                                  "lower_95", "upper_95")

test <- data_frame(c(rep(outcome, length(xlag)), pooled_cp$allRRfit))
?as_tibble
# maybe a bind would work better
outcome_smk_lag_df <- rbind(outcome_smk_lag_df)

pooled_cp$allRRfit
pooled_cp$allRRlow
pooled_cp$allRRhigh

# plot of asthma
plot.crosspred(pooled_cp, type="n", ylim=c(.8, 1.2), ylab="RR", xlab="Lag")
# this chunk of code will plot the county-specific lags (but it's messy)
# so i'm commenting out
# matplot(xlag, county_lag_estimates, type="l", col=grey(0.5),lty=2,add=T)
abline(h=1)
lines(pooled_cp,col=2,lwd=2)
legend ("top","Pooled (with 95%CI)",#,"First-stage region-specific"),
  lty=c(1,2),lwd=1.5,col=c(2,grey(0.7)),bty="n",inset=0.1,cex=0.8)
mtext(text=paste("Cumulative: 10 ug/m^3 increase in GWR Smoke and Outcome ER"))


```

Had some convergence issues. I need to try and figure out a way to find the models that won't converge. Next step would be to try and better understand what's going on, and extend to other outcomes. Maybe look at effect modification by age (age strata)?

Thoughts:
For each outcome, I need to loop through degrees of freedom to find the best AIC (lowest) for the fit of spline for the lag.

Once the best spline fit is found, then i'll produce figures.


